module uart_tx (
    input clk,
    input rst,
    input tx_start,
    input [7:0] tx_data,
    output reg tx,
    output reg tx_busy
);

parameter BAUD_DIV = 5208; // For 9600 baud @50MHz

reg [12:0] baud_cnt = 0;
reg baud_tick = 0;

reg [3:0] bit_cnt = 0;
reg [9:0] shift_reg;

// Baud generator
always @(posedge clk) begin
    if (baud_cnt == BAUD_DIV-1) begin
        baud_cnt <= 0;
        baud_tick <= 1;
    end
    else begin
        baud_cnt <= baud_cnt + 1;
        baud_tick <= 0;
    end
end

// TX logic
always @(posedge clk or posedge rst) begin
    if (rst) begin
        tx <= 1;
        tx_busy <= 0;
        bit_cnt <= 0;
    end

    else begin
        if (tx_start && !tx_busy) begin
            shift_reg <= {1'b1, tx_data, 1'b0}; // Stop + Data + Start
            tx_busy <= 1;
            bit_cnt <= 0;
        end

        if (baud_tick && tx_busy) begin
            tx <= shift_reg[0];
            shift_reg <= shift_reg >> 1;
            bit_cnt <= bit_cnt + 1;

            if (bit_cnt == 9) begin
                tx_busy <= 0;
                tx <= 1;
            end
        end
    end
end

endmodule

module uart_rx (
    input clk,
    input rst,
    input rx,
    output reg [7:0] rx_data,
    output reg rx_done
);

parameter BAUD_DIV = 5208;

reg [12:0] baud_cnt = 0;
reg baud_tick = 0;

reg [3:0] bit_cnt = 0;
reg [9:0] shift_reg;
reg rx_busy = 0;

// Baud generator
always @(posedge clk) begin
    if (baud_cnt == BAUD_DIV-1) begin
        baud_cnt <= 0;
        baud_tick <= 1;
    end
    else begin
        baud_cnt <= baud_cnt + 1;
        baud_tick <= 0;
    end
end

// RX logic
always @(posedge clk or posedge rst) begin
    if (rst) begin
        rx_done <= 0;
        rx_busy <= 0;
        bit_cnt <= 0;
    end

    else begin
        rx_done <= 0;

        // Detect start bit
        if (!rx && !rx_busy) begin
            rx_busy <= 1;
            bit_cnt <= 0;
        end

        if (baud_tick && rx_busy) begin
            shift_reg <= {rx, shift_reg[9:1]};
            bit_cnt <= bit_cnt + 1;

            if (bit_cnt == 9) begin
                rx_busy <= 0;
                rx_data <= shift_reg[8:1];
                rx_done <= 1;
            end
        end
    end
end

endmodule

module uart_top (
    input clk,
    input rst,
    input tx_start,
    input [7:0] tx_data,
    output tx,
    input rx,
    output [7:0] rx_data,
    output rx_done,
    output tx_busy
);

uart_tx TX (
    .clk(clk),
    .rst(rst),
    .tx_start(tx_start),
    .tx_data(tx_data),
    .tx(tx),
    .tx_busy(tx_busy)
);

uart_rx RX (
    .clk(clk),
    .rst(rst),
    .rx(rx),
    .rx_data(rx_data),
    .rx_done(rx_done)
);

endmodule

`timescale 1ns/1ps

module uart_tb;

reg clk;
reg rst;
reg tx_start;
reg [7:0] tx_data;

wire tx;
wire rx;
wire [7:0] rx_data;
wire rx_done;
wire tx_busy;

// Loopback connection
assign rx = tx;

// DUT
uart_top DUT (
    .clk(clk),
    .rst(rst),
    .tx_start(tx_start),
    .tx_data(tx_data),
    .tx(tx),
    .rx(rx),
    .rx_data(rx_data),
    .rx_done(rx_done),
    .tx_busy(tx_busy)
);

// Clock generation (50MHz)
always #10 clk = ~clk;

// Test
initial begin
    clk = 0;
    rst = 1;
    tx_start = 0;
    tx_data = 0;

    #100;
    rst = 0;

    #200;

    // Send data
    tx_data = 8'h55; // 01010101
    tx_start = 1;

    #20;
    tx_start = 0;

    // Wait for receive
    wait(rx_done);

    #200;

    tx_data = 8'hA3;
    tx_start = 1;

    #20;
    tx_start = 0;

    wait(rx_done);

    #500;

    $stop;
end

endmodule
